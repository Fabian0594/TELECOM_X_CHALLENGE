# -*- coding: utf-8 -*-
"""Telecom_X.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JxRbm8JA_6iR3cPb9eNt43vX98Edhnug
"""

import pandas as pd
import requests
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""# IMPORTACIÓN DE DATOS"""

url = "https://raw.githubusercontent.com/alura-cursos/challenge2-data-science-LATAM/refs/heads/main/TelecomX_Data.json"

response = requests.get(url)
response.raise_for_status()

json_data = response.json()
df = pd.json_normalize(json_data, sep='_')
df.info()

df.dtypes

df

renamed_columns = {}
for column in df.columns:
    if column.startswith('customer_'):
        renamed_columns[column] = column.replace('customer_', '')
    elif column.startswith('internet_'):
        renamed_columns[column] = column.replace('internet_', '')
    elif column.startswith('phone'):
        renamed_columns[column] = column.replace('phone_', '')
    elif column.startswith('account'):
        renamed_columns[column] = column.replace('account_', '')
    else:
        renamed_columns[column] = column

df.rename(columns=renamed_columns, inplace=True)

df.columns = df.columns.str.lower()
df.columns

df['charges_daily'] = df['charges_monthly'] / 30
df

"""### Estandarizacion y transformacion de datos"""

columns_to_transform = [
    'churn',
    'partner',
    'dependents',
    'onlinesecurity',
    'onlinebackup',
    'deviceprotection',
    'techsupport',
    'streamingtv',
    'streamingmovies',
    'paperlessbilling',
    'phoneservice',
    'multiplelines',
]

for column in columns_to_transform:
    df[column] = df[column].replace({'Yes': 1, 'No': 0})

print(df)

print(df.describe())

print(df.describe(include='all'))

churn_counts = df['churn'].value_counts()

plt.figure(figsize=(6, 4))
sns.barplot(x=churn_counts.index, y=churn_counts.values)
plt.title('Distribución de Churn (0: No, 1: Sí)')
plt.xlabel('Churn')
plt.ylabel('Número de Clientes')
plt.xticks([0, 1], ['No Churn', 'Churn']) # Para una mejor legibilidad
plt.show()

# Check for unique values in the 'churn' column after transformation
print("Unique values in 'churn' column:", df['churn'].unique())

plt.figure(figsize=(6, 6))
churn_counts = df['churn'].value_counts()
print("Churn counts:", churn_counts)
print("Churn counts index:", churn_counts.index)

# Check the length of churn_counts
print("Length of churn_counts:", len(churn_counts))

# Filter churn_counts to only include 0 and 1
churn_counts = churn_counts[churn_counts.index.isin([0, 1])]

# Check the length again after filtering
print("Length of filtered churn_counts:", len(churn_counts))


plt.pie(churn_counts.tolist(), labels=['No Churn', 'Churn'], autopct='%1.1f%%', startangle=90, colors=['skyblue', 'salmon'])
plt.title('Proporción de Clientes con y sin Churn')
plt.axis('equal')
plt.show()

# Ahora, exploraremos cómo se distribuye la evasión según variables categóricas.

# Identificar columnas categóricas para el análisis
# Excluimos 'customerid' y columnas numéricas continuas como 'tenure', 'charges_monthly', 'charges_daily'
# Las columnas transformadas a 0/1 ('partner', 'dependents', etc.) también son categóricas binarias.
categorical_cols = [
    'gender',
    'partner',
    'dependents',
    'phoneservice',
    'multiplelines',
    'internetservice',
    'onlinesecurity',
    'onlinebackup',
    'deviceprotection',
    'techsupport',
    'streamingtv',
    'streamingmovies',
    'contract',
    'paperlessbilling',
    'paymentmethod'
]

# Iterar sobre las columnas categóricas y visualizar la distribución de churn
for col in categorical_cols:
    plt.figure(figsize=(8, 5)) # Ajusta el tamaño de la figura según sea necesario
    sns.countplot(data=df, x=col, hue='churn', palette='viridis')
    plt.title(f'Distribución de Churn por {col}')
    plt.xlabel(col)
    plt.ylabel('Número de Clientes')
    plt.xticks(rotation=0) # Rotar etiquetas si son largas, ajusta el valor si es necesario
    plt.legend(title='Churn', labels=['No Churn', 'Churn']) # Mejorar la leyenda
    plt.tight_layout() # Ajustar el diseño para evitar superposiciones
    plt.show()

# Ahora, exploraremos cómo las variables numéricas se distribuyen entre los clientes que cancelaron y los que no.

# Identificar columnas numéricas para el análisis
# Excluimos 'customerid' y las columnas categóricas binarias que transformamos a 0/1
numeric_cols = [
    'tenure',
    'charges_monthly',
    'charges_daily', # Incluimos la columna que creamos
    'charges_total'  # Asumiendo que esta columna existe y representa el gasto total
]

# Antes de visualizar, asegúrate de que la columna 'charges_total' sea numérica.
# Podría ser de tipo 'object' debido a valores faltantes o no numéricos.
# Convertiremos a numérica y manejaremos posibles errores (por ejemplo, con NaN).

# Convertir 'charges_total' a numérico, reemplazando errores con NaN
df['charges_total'] = pd.to_numeric(df['charges_total'], errors='coerce')

# Eliminar filas donde 'charges_total' es NaN, o manejarlas de otra forma si es necesario.
# Para este análisis visual, eliminar las filas con NaN en 'charges_total' puede ser simple.
df_cleaned = df.dropna(subset=['charges_total']).copy() # Crear una copia para evitar SettingWithCopyWarning


# Iterar sobre las columnas numéricas y visualizar la distribución de churn
for col in numeric_cols:
    # Asegúrate de que la columna exista en el DataFrame (charges_total podría no existir si hay errores)
    if col in df_cleaned.columns:
        plt.figure(figsize=(8, 5)) # Ajusta el tamaño de la figura según sea necesario
        # Usamos un boxplot para visualizar la distribución (cuartiles, mediana)
        sns.boxplot(data=df_cleaned, x='churn', y=col, palette='viridis')
        plt.title(f'Distribución de {col} por Churn')
        plt.xlabel('Churn (0: No, 1: Sí)')
        plt.ylabel(col)
        plt.xticks([0, 1], ['No Churn', 'Churn']) # Para una mejor legibilidad
        plt.tight_layout() # Ajustar el diseño para evitar superposiciones
        plt.show()

        # Opcionalmente, puedes usar histogramas o gráficos de densidad para ver la forma de la distribución
        plt.figure(figsize=(8, 5))
        sns.histplot(data=df_cleaned, x=col, hue='churn', multiple='stack', kde=True, palette='viridis')
        plt.title(f'Histograma de {col} por Churn')
        plt.xlabel(col)
        plt.ylabel('Frecuencia')
        plt.legend(title='Churn', labels=['No Churn', 'Churn']) # Mejorar la leyenda
        plt.tight_layout()
        plt.show()
    else:
        print(f"Columna '{col}' no encontrada en el DataFrame después de limpiar NaN en 'charges_total'.")